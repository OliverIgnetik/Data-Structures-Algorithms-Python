"""
Maximum Collinear Points
Given an array of distinct points in 2D space, find the maximum number of points that lie on the same line.

Example #1:
Input: [[0, 1], [1, 0], [2, 0]]

         -
         |
         -
         |
         ðŸ”µ
         |
|--|--|--|--ðŸ”µ--ðŸ”µ--|
         |
         -
         |
         -
         |
         -

Output: 2
Explanation: Choose any two points; they lie on the same line. Since the three points arenâ€™t collinear, itâ€™s clear that we canâ€™t do any better.

Example #2:
Input: [[0, 1], [1, 0], [2, 0], [10, 0]]

         -
         |
         -
         |
         ðŸ”µ
         |
|--|--|--|--ðŸ”µ--ðŸ”µ--|--|--|--|--|--|--|--ðŸ”µ--|
         |
         -
         |
         -
         |
         -

Output: 3
Explanation: Choose the points (1, 0), (2, 0), and (10, 0). These three points are collinear, and this is an optimal solution.
"""


class Solution:
    def maximumCollinearPoints(self, points):
        """
        Interface
        ----
        :type points: list of list of int
        :rtype: int

        Approach
        ----
        Slope Approach
        1. A brute force solution is to simply traverse all possible pairs of points and count the number of points that are on the
        line determined by the pair of points we are iterating over.

        2. This gives a cubic-time solution. However, we can reduce our time complexity by utilizing hashing.

        3. Instead of traversing all possible pairs of points, we traverse all possible lines.

        4. For each point in our array, we can compute the slope of the line generated by this point and every other point in our array.

        5. Any two points that have the same slope relative to the point that we are iterating over will lie on the same line.

        6. Thus, we can keep a count of the number of points whose slope relative to the point that we are iterating over is equal to some value,
        and we can take the maximum over all such counters to determine our final answer.

        7. To keep such a counter, one approach is to make a hashtable that maps a floating-point number (representing the slope of each line) to an integer (representing
        a count of the number of points whose slope relative to the current point equals that value).

        8. However, it is usually not a good idea to use floating-point numbers as keys when hashing due to potential precision issues.
        Thus, we instead use strings of the form "dy/dx" (where "dy" and "dx" are the change in y and x-values respectively) as our keys,
        and these keys map to the number of times that this slope appears relative to the point being iterated over.

        9. We also ensure that our fraction is in reduced form by dividing both "dy" and "dx" by their greatest common divisor so that we do
        not end up keeping multiple counters for the same slope value.

        Complexity
        ----
        Time : O(N^2)
        Space : O(N)
        """

        # Shortcut: If we have two or less points, we can take all of them.
        if len(points) <= 2:
            return len(points)

        answer = 0
        for i in range(0, len(points)):

            # Hash Table for storing the slopes
            # In the form of a string
            slope_counter = {}

            # Calulate the slope for each pair
            for j in range(i + 1, len(points)):
                dy = points[j][1] - points[i][1]
                dx = points[j][0] - points[i][0]

                # Gcd is calculated for reducing fractions
                gcd = self.get_gcd(dy, dx)

                # Make sure our fractions are fully reduced.
                dy //= gcd
                dx //= gcd

                # Convert slopes to strings; avoid dealing with floating-point precision.
                signature = f'{dy}/{dx}'
                if signature in slope_counter:
                    slope_counter[signature] += 1
                else:
                    slope_counter[signature] = 1
            # Update the maximum answer
            for key, pointsCountForSlope in slope_counter.items():
                # Add 1 to include the point we iterated off of.
                answer = max(answer, pointsCountForSlope + 1)

        return answer

    # Helper Function to calculate GCD
    # gcd(0,n) = gcd(n,0) = n
    def get_gcd(self, a, b):
        if a == 0:
            return b
        if b == 0:
            return a
        r = a % b

        return self.get_gcd(b, r) if r != 0 else b


i = [[0, 1], [1, 0], [2, 0], [10, 0]]
print(Solution().maximumCollinearPoints(i))
print(Solution().get_gcd(3, 6))
